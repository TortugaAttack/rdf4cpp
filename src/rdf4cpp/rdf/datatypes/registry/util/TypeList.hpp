#ifndef RDF4CPP_REGISTRY_UTIL_TYPE_LIST_HPP
#define RDF4CPP_REGISTRY_UTIL_TYPE_LIST_HPP

#include <rdf4cpp/rdf/datatypes/registry/util/mz/type_list.hpp>

#include <concepts>
#include <optional>
#include <type_traits>

namespace rdf4cpp::rdf::datatypes::registry::util {

namespace type_list_detail {

template<typename F, typename ...Ts>
concept template_invocable = requires (F f) {
                                f.template operator()<Ts...>();
                            };

template<typename R, typename F, typename ...Ts>
concept template_invocable_r = requires (F f) {
                                  { f.template operator()<Ts...>() } -> std::convertible_to<R>;
                              };

template<typename F, auto ...vals>
concept value_template_invocable = requires (F f) {
                                       f.template operator()<vals...>();
                                   };

template<typename F, auto ...vals>
concept nothrow_value_template_invocable = requires (F f) {
                                               noexcept(f.template operator()<vals...>());
                                           };

template<typename R, typename F, typename ...Ts>
concept nothrow_template_invocable = requires (F f) {
                                         noexcept(f.template operator()<Ts...>());
                                     };

template<typename R, typename F, typename TParam, typename RParam>
concept mixed_invocable_r = requires (F f, RParam param) {
                                { f.template operator()<TParam>(param) } -> std::convertible_to<R>;
                            };

template<typename F, typename TParam, typename RParam>
concept nothrow_mixed_invocable = requires (F f, RParam rparam) {
                                      noexcept(f.template operator()<TParam>(rparam));
                                  };


template<typename ...Ts, typename ...Us>
mz::type_list<Ts..., Us...> type_list_cat_impl(mz::type_list<Ts...>, mz::type_list<Us...>);

template<typename MapF, typename ...Ts> requires (template_invocable<MapF, Ts> && ...)
constexpr auto type_list_map_impl(mz::type_list<Ts...>, MapF f) noexcept((nothrow_template_invocable<MapF, Ts> && ...)) {
    return mz::type_list<decltype(f.template operator()<Ts>())...>{};
}

template<size_t ix, typename FindF>
constexpr std::optional<size_t> type_list_find_if_impl(mz::type_list<>, FindF) noexcept {
    return std::nullopt;
}

template<size_t ix, typename FindF, typename T, typename ...Ts> requires (template_invocable_r<bool, FindF, T> && (template_invocable_r<bool, FindF, Ts> && ...))
constexpr std::optional<size_t> type_list_find_if_impl(mz::type_list<T, Ts...>, FindF f) noexcept(noexcept(nothrow_template_invocable<FindF, T> && (nothrow_template_invocable<FindF, Ts> && ...))) {
    if constexpr (f.template operator()<T>()) {
        return ix;
    } else {
        return type_list_find_if_impl<ix + 1>(mz::type_list<Ts...>{}, f);
    }
}

template<typename FoldF, typename Acc, typename ...Ts> requires (mixed_invocable_r<Acc, FoldF, Ts, Acc> && ...)
constexpr Acc type_list_fold_impl(mz::type_list<Ts...>, Acc init, FoldF f) noexcept(noexcept((nothrow_mixed_invocable<FoldF, Ts, Acc> && ...))) {
    ((init = f.template operator()<Ts>(std::move(init))), ...);
    return init;
}

template<size_t ...ixs, typename F> requires (value_template_invocable<F, ixs> && ...)
constexpr auto type_list_generate_impl(std::index_sequence<ixs...>, F f) noexcept(noexcept((nothrow_value_template_invocable<F, ixs> && ...))) {
    return mz::type_list<decltype(f.template operator()<ixs>())...>{};
}

} // namespace type_list_detail


/**
 * Concatenates two type lists
 *
 * @tparam ListA the first type list
 * @tparam ListB the second type list
 * @return the concatenated list
 *
 * @example
 * @code
 * using list_a_t = mz::type_list<int>;
 * using list_b_t = mz::type_list<void>;
 *
 * using new_list_t = type_list_cat<list_a_t, list_b_t>;
 *
 * static_assert(std::is_same_v<new_list_t, mz::type_list<int, void>>);
 * @endcode
 */
template<typename ListA, typename ListB>
using type_list_cat = decltype(type_list_detail::type_list_cat_impl(ListA{}, ListB{}));


/**
 * Map each type in a type list using a unary template operation f
 * and store the results in a another type list.
 *
 * @tparam List the type list to map over
 * @param f a template-unary operation to map the types
 * @return the type list generated by applying f to each type in tup
 *
 * @example
 * @code
 * using list_t = mz::type_list<int &, double &, std::string &>;
 *
 * using new_list_t = decltype(type_list_map<list_t>([]<typename T>() {
 *      return std::remove_reference_t<T>{};
 * }));
 *
 * static_assert(std::is_same_v<new_list_t, mz::type_list<int, double, std::string>>>;
 * @endcode
 */
template<typename List, typename MapF>
constexpr auto type_list_map(MapF f) noexcept(noexcept(type_list_detail::type_list_map_impl(List{}, f))) {
    return type_list_detail::type_list_map_impl(List{}, f);
}


/**
 * Tries to find the index in the tuple where the type matches the predicated pred.
 *
 * @note Pred will be called as pred.template operator()<Element>() on each element of the tuple and is expected to
 *      return a boolean indicating if the predicate matched.
 * @return the index of the first type matching the predicate if there is one, else std::nullopt
 *
 * @example
 * @code
 * using list_t = mz::type_list<std::string, double, int>;
 *
 * constexpr std::optional<size_t> ix = type_list_find_if<list_t>([]<typename T>() {
 *     return std::is_integral_v<T>;
 * });
 *
 * static_assert(ix.has_value() && *ix == 2);
 * @endcode
 */
template<typename List, typename Pred>
constexpr std::optional<size_t> type_list_find_if(Pred pred) noexcept(noexcept(type_list_detail::type_list_find_if_impl<0>(List{}, pred))) {
    return type_list_detail::type_list_find_if_impl<0>(List{}, pred);
}


/**
 * Fold all elements in a type list into a single object.
 * The provided function f will be repeatedly called as f.template operator()<Element>(acc) for each type in the
 * list and is expected to return the acc for the next invocation.
 *
 * @tparam List the type list to fold over
 * @tparam Acc the type of the accumulator
 * @param init the initial value of the accumulator
 * @param f a mixed template param/normal param binary operation that will be called with the the current element type and accumulator and should return the new accumulator
 * @return the final accumulator value
 *
 * @example
 * @code
 * using list_t = mz::type_list<int, double, float>;
 *
 * std::string all_types = type_list_fold<list_t>(std::string{}, []<typename T>(std::string &&acc) {
 *     return std::move(acc) + typeid(T).name() + " ";
 * });
 * @endcode
 */
template<typename List, typename Acc, typename FoldF>
constexpr Acc type_list_fold(Acc init, FoldF f) noexcept(noexcept(type_list_detail::type_list_fold_impl(List{}, std::move(init), f))) {
    return type_list_detail::type_list_fold_impl(List{}, std::move(init), f);
}

/**
 * Equivalent to type_list_fold except that the return value is discarded
 */
template<typename List, typename Init, typename FoldF>
constexpr void type_list_for_each_with(Init init, FoldF f) noexcept(noexcept(type_list_fold<List>(std::move(init), f))) {
    type_list_fold<List>(std::move(init), f);
}

/**
 * Generates a type list of count by repeatedly calling f.template operator()<ix>() for
 * all indices in [0, count).
 *
 * @param f a value template callable function that generates the types
 * @return a type list with the generated types
 *
 * @example
 * @code
 * using list_t = decltype(type_list_generate<2>([]<size_t ix>() {
 *    return std::integral_constant<size_t, ix>{};
 * }));
 *
 * static_assert(std::is_same_v<list_t, mz::type_list<std::integral_constant<size_t, 0>, std::integral_constant<size_t, 1>>>);
 * @endcode
 */
template<size_t count, typename F>
constexpr auto type_list_generate(F f) noexcept(noexcept(type_list_detail::type_list_generate_impl(std::make_index_sequence<count>{}, f))) {
    return type_list_detail::type_list_generate_impl(std::make_index_sequence<count>{}, f);
}

/**
 * Check if all given types in the Ts parameter pack are equal.
 * @tparam Ts types to check for equality
 */
template<typename... Ts>
struct all_types_same : std::false_type {};

template<>
struct all_types_same<> : std::true_type {};

template<typename T, typename... Ts>
struct all_types_same<T, Ts...> : std::bool_constant<(std::is_same_v<T, Ts> && ...)> {};

} // namespace rdf4cpp::rdf::datatypes::registry::util {

#endif  //RDF4CPP_REGISTRY_UTIL_TYPE_LIST_HPP
