#ifndef RDF4CPP_UTIL_HPP
#define RDF4CPP_UTIL_HPP

#include <tuple>
#include <type_traits>
#include <utility>

namespace rdf4cpp::rdf::datatypes::registry::util {

namespace tuple_util_detail {

/**
 * tuple map implementation
 */
template<typename F, typename TupleLike, size_t ...Ixs>
constexpr auto tuple_map_impl(TupleLike &&tup, F &&f, std::index_sequence<Ixs...>) {
    return std::make_tuple(f(std::get<Ixs>(std::forward<TupleLike>(tup)))...);
}

/**
 * tuple fold implementation
 */
template<typename Acc, typename F, typename TupleLike, size_t ...Ixs>
constexpr Acc tuple_fold_impl(TupleLike &&tup, Acc init, F &&f, std::index_sequence<Ixs...>) {
    ((init = f(std::move(init), std::get<Ixs>(std::forward<TupleLike>(tup)))), ...);
    return init;
}

} // namespace tuple_util_detail

/**
 * Map each element in a tuple using a unary operation f
 * and store the results in a another tuple.
 *
 * @param tup a std::tuple like object to map over
 * @param f a unary operation to map the elements
 * @return the tuple generated by applying f to each element in tup
 */
template<typename F, typename TupleLike>
constexpr auto tuple_map(TupleLike &&tup, F &&f) {
    constexpr size_t tup_size = std::tuple_size_v<std::remove_cvref_t<TupleLike>>;
    return tuple_util_detail::tuple_map_impl(std::forward<TupleLike>(tup), std::forward<F>(f), std::make_index_sequence<tup_size>{});
}

/**
 * Fold all elements in a tuple into a single object
 *
 * @tparam Acc the type of the accumulator
 * @param tup a std::tuple like object to fold
 * @param init the initial value of the accumulator
 * @param f a binary operation that will be called with the accumulator and the current element and should return the new accumulator
 * @return the final accumulator value
 */
template<typename Acc, typename F, typename TupleLike>
constexpr Acc tuple_fold(TupleLike &&tup, Acc init, F &&f) {
    constexpr size_t tup_size = std::tuple_size_v<std::remove_cvref_t<TupleLike>>;
    return tuple_util_detail::tuple_fold_impl(std::forward<TupleLike>(tup), std::move(init), std::forward<F>(f), std::make_index_sequence<tup_size>{});
}

/**
 * Equality function object for tuples of the form std::tuple<T, T> where
 * the order of the tuple should be disregarded.
 *
 * => UnorderedPairEqual{}(std::make_tuple(a, b), std::make_tuple(b, a)) == true
 *
 * @tparam T
 */
template<typename T = void>
struct UnorderedPairEqual {
    constexpr bool operator()(std::tuple<T, T> const &lhs, std::tuple<T, T> const &rhs) const noexcept {
        return lhs == rhs
               || lhs == std::tie(std::get<1>(rhs), std::get<0>(rhs));
    }
};

/**
 * Transparent version of UnorderedPairEqual
 */
template<>
struct UnorderedPairEqual<void> {
    using is_transparent = void;

    template<typename T, typename U>
    constexpr bool operator()(std::tuple<T, T> const &lhs, std::tuple<U, U> const &rhs) const noexcept {
        return lhs == rhs
               || lhs == std::tie(std::get<1>(rhs), std::get<0>(rhs));
    }
};

/**
 * Hasher function object to hash tuples of the form std::tuple<T, T>
 * where the order of elements should be disregarded.
 *
 * => UnorderedPairHash{}(std::make_tuple(a, b)) == UnorderedPairHash{}(std::make_tuple((b, a))
 *
 * @tparam T
 * @tparam Hasher the hasher that should be used to hash the individual elements
 */
template<typename T = void, typename Hasher = std::hash<T>>
struct UnorderedPairHash {
    constexpr size_t operator()(std::tuple<T, T> const &pair) const noexcept {
        return Hasher{}(std::get<0>(pair)) ^ Hasher{}(std::get<1>(pair));
    }
};

/**
 * Transparent version of UnorderedPairHash
 * @tparam Hasher
 */
template<typename Hasher>
struct UnorderedPairHash<void, Hasher> {
    using is_transparent = void;

    template<typename T>
    constexpr size_t operator()(std::tuple<T, T> const &pair) const noexcept {
        return Hasher{}(std::get<0>(pair)) ^ Hasher{}(std::get<1>(pair));
    }
};

} // namespace rdf4cpp::rdf::datatypes::registry::util

#endif  //RDF4CPP_UTIL_HPP
